/**
 * 事件委托（事件代理）
 * 利用事件冒泡传播机制，（mouseenter和mouseleave没有冒泡所以就没有事件委托）
 * 如果一个容器的后代元素中，很多元素的点击行为（其他事件行为也是）都要做一些处理
 * 此时我们不需要在像以前一样一个个获取一个个绑定了，我们只需要给容器的click绑定方法即可，
 * 这样不管点击的是哪一个后代元素，都会根据冒泡传播的传递机制，把容器的click行为触发，把对应的
 * 方法执行，根据事件源，我们可以知道点击的是谁，从而做不同的事情即可
 * 
 */
document.onclick = function(ev){
  ev = ev || window.event;
  ev.target = ev.target || ev.srcElement;
  console.log(ev.target.id,ev.target.tagName);
}

/**
 * 什么时候用事件委托
 * 1、容器中很多后代元素的某个行为要进行操作，委托给容器处理是不错的选择
 * 2、元素是动态绑定的
 * 3、需求是除了某某某，剩下的操作都是不同样的事情（此时把点击行为的操作委托
 * 给BODY，事件源是某某做什么，不是统一做什么）
 */
